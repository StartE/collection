# 1. RxJS 操作符

## 1.1 基础概念

>操作符是函数，它基于当前的 Observable 创建一个新的 Observable。这是一个无副作用的操作：前面的 Observable 保持不变。

**操作符分类**

+ 静态：创建操作符(如create、interval等)及一些组合操作符(如 concat，merge等).

```javascript
var observable2 = Rx.Observable.interval(400);

var merged = Rx.Observable.merge(observable1, observable2);
```

+ 实例: 用this关键字来指代输入的Observable的函数。

```javascript
Rx.Observable.prototype.multiplyByTen = function multiplyByTen() {
  var input = this;
  return Rx.Observable.create(function subscribe(observer) {
    input.subscribe({
      next: (v) => observer.next(10 * v),
      error: (err) => observer.error(err),
      complete: () => observer.complete()
    });
  });
}
```

这里 input Observable并不是multiplayByTen()的参数，而是指this对象。

# 2. 按照功能分类

## 2.1 创建

+ *ajax*
+ create
+ empty
+ from
+ fromEvent
+ interval
+ of
+ throw
+ timer

**create**

`create( onSubscription: function(observer:Observer) )`创建一个新的Observable，当Observer订阅该Observable时，它会执行指定的函数。绝大多数情况下你不需要使用`create`，因为现有的操作符创建出来的 Observable 能满足绝大多数使用场景。

示例：发出三个数字，然后完成。

```javascript
var observable = Rx.Observable.create(function(observer){
    observer.next(1);
    observer.next(2);
    observer.complete();
});

observable.subscribe(
    value => console.log(value),
    err => {},
    () => console.log('end')
);
```
结果：
```
1
2
end
```
示例：发出一个错误
```javascript
const observable = Rx.Observable.create((observer) =>{
    observer.error('something went wrong with ...');
})

observable.subscribe(
    v => console.log(v),// will never happen
    e => console.log(e),
    () => console.log('complete')//will never happen
);
```
结果：
```
something went wrong with ...
```

示例：返回取消订阅函数
```javascript
const observable = Rx.Observable.create(observer =>{
    const id = setTimeout( () => observer.next('...'), 5000 );//5s 后发出'...'

    return () => { clearTimeout(id); console.log('cleared!');};
});

const subscription = observable.subscribe( value => consoel.log(value) );
setTimeout( () => subscription.unsubscribe(),3000 ); //3s 后取消订阅
```
结果，3s后
```
cleared!
```
而`'...'`将永远不会发出，因为5s后已经取消订阅了，假如将5000改成2000，则2s后先发出`'...'`,第3秒又发出`'cleared!'`.

**empty**

`empty()`创建一个简单的只发出完成状态通知的 Observable,通常情况下用于和其他Observables进行组合，如在mergeMap中使用。

示例：empty() 会立刻完成
```javascript
const example = Rx.Observable.empty();
const subscribe = example.subscribe({
    next: () => console.log('Next'),
    complete: () => console.log('Complete')
});
```
结果
```
Complete
```
示例：仅将奇数映射并打平成字母序列abc.
```javascript
var interval = Rx.Observable.interval(1000);
var result = interval.mergeMap( x => x%2 === 1? Rx.Observable.of('a','b','c') : Rx.Observable.empty() );
result.subscribe( x => console.log(x));
```
结果：
```javascript
//0s后 什么都不输出
//1s后
a
b
c
//2s后 什么都不输出
//3s后
a
b
c
//4s后 什么都不输出
//5s后
a
b
c
……
```

**from**

from将Promise、类数组对象，迭代器对象转化为Observable,该Observable发出promise、数组或者迭代器成员。这里，字符串被当做字符数组。

示例：将数组转化为Observable
```javascript
var array = [10,20,30];
var result = Rx.Observable.from(array);
result.subscribe( x => console.log(x));
```
结果
```
10
20
30
```
示例：将一个无限的迭代器(来自于generator)转化为Observable

```javascript
function* generateDoubles(seed){
    var i = seed;
    while(true){
        yield i;
        i = 2*i;
    }
}

var iterator = generateDoubles(3);
var result = Rx.Observable.from(iterator).take(10);
result.subscirbe(x => console.log(x));
```
结果：
```
3
6
12
24
48
96
192
384
768
1536
```
示例：将promise转化为Observable
```javascript
const promiseSource = Rx.Observable.from(new Promise(resolve => resolve('Hello world')));

const subscribe = promiseSource.subscribe(val => console.log(val));
```
结果：
```
Hello World
```

示例：将字符串转换为Observable
```javascript
const source = Rx.Observable.from('hello');
const subscribe = source.subscribe(val => console.log(val));
```
结果：
```
h
e
l
l
0
```
**fromEvent**

`fromEvent`创建一个来自于DOM事件，或者Node的EventEmitter事件或其他事件的Observable。

示例： 鼠标事件转换而来的Observable
```javascript
const source = Rx.observable.fromEvent(document,'click');//创建发出点击事件的Observable
const example = source.map(event => `Event time:${event.timeStamp}`);
const subscribe = example.subscribe(val => console.log(val));
```
结果如下：
```
"Event time: 4577.865"
"Event time: 5586.155000000001"
"Event time: 7113.42"
"Event time: 7825.860000000001"
……
```
**interval**

`interval`是基于指定的时间间隔发出连续的数字序列的Observable

示例：每1秒发出数字序列中的值

```javascript
const source = Rx.Observable.interval(1000);
const subscribe = source.subscirbe(val => console.log(val));
```
结果：
```
0
1
2
3
……
```

**of**

`of`发出你提供的参数，然后完成。

示例：发出10,20,30，a,b,c，1s后每秒发出0,1,2...序列
```javascript
var numbers = Rx.Observable.of(10,20,30);
var letters = Rx.Observable.of('a','b','c');
var interval = Rx.Observable.interval(1000);

var result = numbers.concat(letters).concat(interval);
result.subscribe(x => console.log(x));
```
结果：
```
10
20
30
a
b
c
0 //1s后
1
2
……
```

**throw**

`throw`仅抛出错误信息

```javascript
var interval = Rx.Observable.interval(1000);
var result = interval.mergeMap(x =>
  x === 3 ?
    Rx.Observable.throw('Three are bad') :
    Rx.Observable.of('ok')
);
result.subscribe(x => console.log(x), e => console.error(e));
```
结果：
```
ok
ok
ok
Three are bad //抛出error再也不会有新的值输出了，至此结束
```

**timer**

`timer`创建一个延时delay，timer(delay,period),在初始延时delay之后按照每个period发送自增的数字。

示例：
```javascript
var numbers = Rx.Observable.timer(3000,1000);
numbers.subscribe(x => console.log(x));
```
结果：
```
//3s 后
0
1
2
……
```

示例：
```javascript
var numbers = Rx.Observable.timer(5000);
numbers.subscribe(x => console.log(x));
```
结果：
```
//5s 后
0
1
2
……
```
## 2.2 转换

+ buffer
+ bufferCount
+ contactMap
+ map
+ mapTo
+ scan
+ switchMap

**buffer**

`buffer`是缓冲源Observable的值到一个数组中,直到closingNotify发出通知才发出此数组

```javascript
var interval = Rx.Observable.interval(1000);//source
var clicks = Rx.Observable.fromEvent(document,'click');//click 事件发出notify
var buffered = interval.buffer(clicks);
buffered.subscribe(x => console.log(x));
```
结果可能是
```
[0,1,2] //第3s 后点击了一次
[3,4] //第5s 后点击了一次
[] //点击过快，距离上次点击不到1s,source没有发出数据
[5] //第6s 点击一次
```

**bufferCount**

`bufferCount`收集发出的值，直到收集完提供的数量的值才将其作为数组发出。

```javascript
var source = Rx.Observable.interval(1000)
var buffered = source.bufferCount(2);
buffered.subscribe(x => console.log(x));
```
结果：
```
[0,1]
[2,3]
[4,5]
……
```

**concatMap**

`concatMap`返回一个Observable,该Observable发出基于对源Observable发出的值调用提供的函数，该函数返回所谓的内部Observable，每个新的内部Observable和前一个内部Observable连接在一起。

示例：
```javascript
// 发出 'Hello' 和 'Goodbye'
const source = Rx.Observable.of('Hello', 'Goodbye');
// 将 source 的值映射成内部 observable，当一个完成发出结果后再继续下一个
const example = source.concatMap(val => Rx.Observable.of(`${val} World!`,`${val} You!`));
const subscribe = example.subscribe(val => console.log(val));
```
结果：
```
"Hello World!"
"Hello You!"  //当一个完成发出结果后再继续下一个
"Goodbye World!"
"Goodbye You!"
```

示例：每次点击都会触发从0到3的定时器(时间间隔为1秒)，定时器之间是串行的
```javascript
var clicks = Rx.Observable.fromEvent(document, 'click');
var result = clicks.concatMap(event => Rx.Observable.interval(2000).take(3));
result.subscribe(x => console.log(x));
```

结果：第一个点击的完成,才会输出第二个点击的完成
```
//click 
//2s 后
0
//2s 后
1
//2s 后
2


//再次click
//2s 后
0
//2s 后
1
//2s 后
2

……
```
## 2.3 过滤

+ debounce
+ debounceTime
+ elementAt
+ filter
+ first
+ ignoreElements
+ last
+ sample
+ sampleTime
+ skip
+ skipUntil
+ skipWhile
+ take
+ takeUntil
+ takeWhile
+ throttle
+ throttleTime

## 2.4 组合

+ combineAll
+ combineLatest
+ concat
+ concatAll
+ forkJoin
+ merge
+ mergeAll
+ race
+ startWith
+ switch
+ withLastestFrom
+ zip
+ zipAll

## 2.5 多播

+ cache
+ multicast
+ publish
+ share

## 2.6 错误处理

+ catch
+ retry

## 2.7 工具

+ do
+ delay
+ *finally*
+ *let*
+ timeInterval
+ timestamp
+ toArray
+ toPromise

## 2.8 条件和布尔

+ defaultIfEmpty
+ every
+ find
+ isEmpty

## 2.9 数学和聚合

+ count
+ max
+ min
+ reduce


**参考**：

[RxJs 中文版](http://cn.rx.js.org/class/es6/Observable.js~Observable.html)

[RxJs Operator 弹珠示例](http://rxmarbles.com/)

[Learn rxjs operators](https://rxjs-cn.github.io/learn-rxjs-operators/operators/creation/of.html)