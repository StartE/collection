# Understanding RxJS

RxJS 是一个针对事件的库。

>RxJS是一个通过使用可观察序列来构建异步和基于事件的程序的库。它提供了一个核心类型:Observable、卫星类型(大概是这些类型均围绕于Observable，也就是Observable是根基，而这些是辅助类型):Observer、Schedulers、Subjects)和操作符-衍生自一些数组方法，使得我们可以把异步事件以集合的方式进行处理。

## RxJS 基本概念

* Observable: 可观察对象，是一个可被调用的未来值或事件的集合
* Observer: 观察者， callback函数，知道如何监听被Observable发送的值
* Subscription: 订阅, 表示一个可观察对象的执行，主要用于取消执行
* Operators: 操作符，以函数式编程的方式处理集合 比如 map,filter,contact, flatmap
* Subject：主题，等同于一个事件驱动器，是将一个值或事件广播到多个观察者的唯一途径
* Schedulers: 调度者，用来控制并发，当计算发生时允许我们协调，如setTimeout， requestAnimationFrame

## 示例1

通常这样注册事件监听
```javascript
var button = document.querySelector('button');
button.addEventListener('click',() => console.log('clicked'));
```
使用RxJS 创建一个可观察对象
```javascript
var button = document.querySelector('button');
Rx.Observable.fromEvent(button,'click')
    .subscribe(() => console.log('clicked'));
```

## Purity 纯函数

RxJX 能够使用纯函数的方式提升产值，减少错误提升

一个非纯函数如下：
```javascript
var count = 0;
var button = document.querySelector('button');
button.addEventListener('click',() => console.log(`Clicked ${++count} times`));
```
使用RxJS来隔离你的状态
```javascript
var button = document.querySelector('button');
Rx.Observale.fromEvent(button,'click')
    .scan(count =>count + 1 ,0)
    .subscribe(count => console.log(`Clicked ${count} times`));
```
scan operator 和数组中reduce类似，将0传递给回调函数count => count + 1;回调函数的返回值成为下一次回调函数运行时要传递的参数值

## Flow流

RxJS 有很多operator，可以控制事件流入可观察对象observables.

用纯JavaScript实现 “每秒最多只能点击一次”
```javascript
var count = 0;
var rate = 1000;
var lastClick = Date.now() - rate;
var button = document.querySelector('button');
button.addEventLister('click', () =>{
    if(Date.now() - lastClick >= rate){
        console.log(`Clicked ${++count} times`);
        lastClick = Date.now();
    }
});
```
使用RxJS 
```javascript
var button = document.querySelector('button');
Rx.Observable.fromEvent(button,'click')
    .throttleTime(1000)
    .scan(count => count + 1,0)
    .subscribe(count => console.log(`Clicked ${count} times`));
```
其他的流操作符如filter，delay,debounceTime, take,takeUntil, distinct, distinctUntilChanged等等

## Values 值

纯JS实现获取每次点击鼠标时X坐标位置
```javascript
var count = 0;
var rate = 1000;
var lastClick = Date.now() - rate;
var button = document.querySelector('button');
button.addEventListener('click',(event) =>{
    if(Date.now() - lastClick >= rate){
        console.log(++count + event.clientX)
        lastClick = Date.now();
    }
})
```

用RxJS实现如下
```javascript
var button = document.querySelector('button');
Rx.Observable.fromEvent(button,'click')
    .throttleTime(1000)
    .map(event => event.clientX)
    .scan( (value,clientX)  => value + clientX ,  0 )
    .subscribe( value => console.log(`Clicked ${value} times`));
```

> 不太理解此处？？？存疑

其他的生产者还有pluck, pairwise, sample 等等

下面来一一探索每个概念

主要参考[buctwbzs.gitbooks.io/rxjs](https://buctwbzs.gitbooks.io/rxjs/content/observable.html)


# Observable 观察对象

observable 以惰性的方式推送多值得集合，如果不订阅则不会推送

|              | Single Value   |Multiple Value    |
|--------------|:--------------:|:----------------:|
|pull          |function        |iterator          |
|push          |promise         |Observabel        |

## Pull VS Push

Pull 和 Push 是Data Producer 和Data consumer之间交流的方式。
Pull 是指 Data consumer 决定何时从Data producer 那里获取数据，对于Data producer来讲并不意识何时发生数据到consumer。因此Data producer 是passive的一方，consumer是active的一方。每一个JS函数都是一个“拉”的实践，函数式数据的生产者，consumer调用函数，“拉”出一个单一的return来消费该数据，ES6中的iterator 和generator 是另一种“拉”，消费者调用iterator.next(),从中拉取多个值。

Push 是指Data producer决定何时发生数据给consumer，consumer在接收数据之前并没有意识何时接收，因此producer是active的一方，consumer是passive的一方。promise是最常见的Push实践，一个data producer 决定何时数据推送到consumer。

RxJS 引入Observable，一个全新的**PUSH体系**，一个Observable是一个生产多值得producer，并推送给Oberver.

* Function
* Generator
* Promise
* Observable

## Obervable 一个更一般化的函数

Observable就是一个更加一般的函数，但是允许返回多个值使其更加一般化。
思考下面的程序
```javascript
function foo(){
    console.log('hello');
    return 42;
}

var x = foo.call();
console.log(x);

var y = foo.call();
console.log(y);
```
可以看到输出如下：
hello
42
hello
42

使用Observable得到同样的结果
```javascript
var foo = Rx.Observabel.create(function(observer){
    console.log('hello');
    observer.next(42);
});

foo.subscribe(function(x){
    console.log(x);
});
foo.subscribe(function(x){
    console.log(x);
});
```
同样得到输出
hello
42
hello
42

可以看出function和Observable 都是惰性计算，不去call 不去subscribe则永远不会发生，并且call 和subscribe都是独立操作。因此可以说**订阅一个Observable类似于调用一个Function**。

Observable是异步的吗？这并不确切，示例如下：

```javascript
console.log('before');
console.log(fool.call());
console.log('after');
```
可以得到
before
hello
42
after

类似的，假若使用Observable：

```javascript
console.log('before');
foo.subscribe(function(x){
    console.log(x);
})
console.log('after');
```
同样得到
before
hello
42
after

以上可以显示对foo的订阅是完全同步的，就像调用一个函数。

Observable与Function最大的不同是**Observable可以随时间return多个值，而函数只能return一个**。例如以下代码

```javascript
function foo(){
    console.log('hello');
    return 42;
    return 100; //dead code . will nerver happen.
}
```
可见，函数仅仅可以返回一个值

```javascript
var foo = Rx.Observable.create(function (observer)){
    console.log('hello');
    observer.next(42);
    observer.next(100);
    observer.next(300);
});

console.log('before');
foo.subscribe(function(x){
    console.log(x);
});
console.log('after');
```

同步输出 before hello 42 100 300 after

当然也可以选择异步的方式返回值

```javascript
var foo = Rx.Observable.create(function (observer)){
    console.log('hello');
    observer.next(42);
    observer.next(100);
    setTimeout(
        () => {observer.next(300);} // happens asynchronomously
        ,1000);
});

console.log('before');
foo.subscribe(function(x){
    console.log(x);
});
console.log('after');
```

输出 before hello 42 100 200 after 300

总结：
1. fun.call() 意味着同步给出*一个*值
2. ovservable.subscribe() 一位置给出*一个或多个*值，可以*同步*也可以*异步*

## 剖析Observable

核心概念包括四步：

* Creating Observables 创建
* Subscribing to Observables 订阅
* Executing the Observables 执行
* Disposing Observables 处理

**Create Observables**

Rx.Observable.create 是可观察对象构造函数的别名，它接受一个参数：the subscribe function.

下面的例子创造一个每秒向观察者发射一个字符串“hi"的可观察对象

```javascript
var obserable = Rx.Observable.create(
    function subscribe(observer){
        var id = setInterval( () =>{
            observer.next('hi')
        })
    }
)
```
**Subscribe Observable**

观察对象可以被订阅，例如下面这样

```javascript
observable.subscirbe(x => console.log(x));
```

`observable.subscribe`和`Observable.create(function subscribe(observer){})` 的subscribe 回调函数有着同样的名字，但在RxJS中，其意义不同，可以认为其在概念上是等价的。

对同一可观察对象进行订阅的多个观察者之间的回调函数是不共享信息的。不同的obserber调用`observable.subscribe`时，`Observable.create(function subscibe(observer){})`中的subscribe函数，每次调用observable.subscribe为给定的observer触发其自身独立的设定程序。

**执行Observable**

在`Observable.create(function(observer){...})`中的代码，表示了一个可观察对象的执行，一个仅在观察者订阅时候发生的惰性计算。执行随着时间产生多个值，以同步或异步的方式。

下面是Observable执行时可以发送的三种类型的值

* *Next*:发送一个数字/字符串/对象等值。
* *Error*: 发送一个JS错误或者异常。
* *Complete*：不发送值。

Next通知是最重要且最常见的类型，它代表了发送给观察者的确切数据，Error和Complete通知可能仅在Observable对象执行期间仅发生一次，但仅会执行二者之一。 一个Observable执行期间，零到无穷多个next通知被发送，如果error或者complete通知一旦被发送，此后不再发送任何值。

用正则表达式表示此规则`next*(error|complete)`

下面这个例子，可观察对象执行然后发送三个next通知，然后Completes,永远不会发送第四个:

```javascript
var observable = Rx.Observable.create( function subscribe(observer){
    observer.next(1);
    observer.next(2);
    observer.next(3);
    observer.complete();
    observer.next(4); // It will not delivered 
});
```

可以用try/catch 语句包裹通知语句，如果捕获了异常将会发送一个错误通知。

```javascript
var observable = Rx.Observable.create(function subscribe (observer){
    try {
        observer.next(1);
        observer.next(2);
        observer.next(3);
        observer.complete();
    }catch (err){
        observer.error(err); //delivers an error if it caight one
    }
});
```

**处理可观察对象的执行**

由于Observable的执行是无限的（不停地next),而对于观察者来说却希望在有限的时间内停止执行，因此我们需要一个API来取消执行。因为每一次执行仅仅服务于一个observer，一旦observer停止接收数据，它就不得不通过一个方法去终止执行，从而避免大量计算性能和内存资源的浪费。

当observable.subscribe 被调用时，observer将专注于最新被创建的可观察对象的执行，并且这个调用返回一个对象：*the Subscription*

```javascript
var subscription = observable.subscirbe( x => console.log(x));
```
*the Subscription* 表示正在进行的*执行*，可以用subscription.unsubscibe()表示取消正在进行的执行：

```javascript
var observable = Rx.Observable.from([10,20,30]);
var mySubscription = observable.subscribe(x => console.log(x));
//later ...
mySubscription.unsubscribe();
```

下面将演示一个示例，清除一个`setInterval()`间隔的执行

```javascript
var observable = Rx.Observable.create(function subscribe(observer){
    //keep track of the interval resource
    var intervalID = setInterval( () =>{observer.next('hi');}, 1000 );

    //provide a way of canceling and disposing the interval resources

    return function unsubscribe(){
        clearInterval(intervalID);
    };
});
```
就像`observable.subscribe` 类似于`Observable.create(function subscribe(){...})`,我们从subscribe函数中返回的return unsubscribe 函数在概念上也就等价于subscription.unsubscription,事实上，如果我们去除这些概念中的ReactiveX类型，也就剩下了更加直观的JavaScript。

```javascript
function subscribe(observer){
    var intervalID = setInterval(() =>{
        observer.next('hi')
    },1000);
    return function unsubscribe(){
        clearInterval(intervalID);
    };
}

var myUnsubscribe = subscribe({ next : (x) => console.log(x)});

//Later
myUnsubscribe(); //dispose the resources
```
我们使用Observable, Observer, Subscription 等Rx类型的原因是因为能够兼顾安全性和操作符的可组合性。

# Observer 观察者

Observer是Observable所发送数据的消费者，简而言之，是一组回调函数，分别对应一种被可观察对象发送的通知的类型：next,error,complete。 下面是个典型的Observer的例子：

```javascript
var observer1 = {
    next : x => console.log('Observer got a new value: '+x) ,
    error : err => console.log('Observer got an error: '+err),
    complete: () => console.log('Observer got a complete notification')
}
```

去使用观察者observer，需要订阅可观察对象Observable

```javascript
observable.subscribe(observer1)
```
观察者不过是三个回调函数组成的*对象*，每个回调函数分别对应可观察对象的通知类型。RxJS的观察者是可选的，假如不提供某个回调函数，Observer的执行依然会照常发生，只是此类型的通知不会发生，因为在Observer中没有对应的回调函数。

例如下面是一个没有Complete通知的例子：
```javascript
vae observer = {
    next : x => console.log('Observer got a new value: '+x) ,
    error : err => console.log('Observer got an error: '+err)
}
```
当订阅一个可观察对象时，可以仅仅提供回调来作为参数就够了，而不需要完整的Observer对象，示例如下：
```javascript
observable.subscribe( x => console.log('Observer got a next value' + x))
```
在observable.subscribe内部，它将使用第一个回调参数作为next的处理句柄创建一个观察者对象。也可以通过将三个函数作为参数提供三种回调:

```javascript 
observable.subscribe(
    x => console.log('Observer got a next value: ' + x),
    err => console.error('Observer got an error: ' + err),
    () => console.log('Observer got a complete notification')
);
```

# Subscription 订阅

订阅是一个表示一次性资源的对象，通常是*一个可观察对象的执行*。 订阅对象有一个非常重要的方法，unsubscribe，该方法不需要参数，仅仅去废掉可观察对象所持有的资源。在以往的RxJS版本中，*Subscription*被称为*Disposable*

订阅对象有一个unsubscribe() 方法用来释放资源或者取消可观察对象的执行。

```javascript
var observable = Rx.Observable.interval(1000);
var subscription = observable.subscribe(x => console.log(x)); 
//Later

// This cancels the ongoing Observable execution which was started by calling subscribe with an Observer.
subscription.unsubscribe();
```

订阅对象可以被放置在一起，因此对一个订阅对象的unsubscribe()进行调用，可以对多个订阅进行取消。具体做法是：把一个订阅“加”到另一个订阅。

```javascript
var observable1 = Rx.Observable.interval(400);
var observable2 = Rx.Observable.interval(300);

var subscription = observable1.subscribe(x => console.log('first:' + x));
var childSubscription = observable2.subscribe( x => console.log('second:' +x));

subscription.add(childSubscription);
setTimeout( () =>{
    subscription.unsubscribe(); // unsubscribe BOTH subscription & childSubscription;
    }, 1000)
}
```
执行后再后台得到:

```
second: 0
first: 0
second: 1
first: 1
second: 2
```
subscription也有一个`subscription.remove(otherSubscription)`的方法，用于解除被`add`添加的订阅。

# Subject 主题

